{"chunk":6,"numChunks":7,"fileHash":"5AYblwm6C9jOmbWeNdgaeHg1BchKJpa79BOSp3ALZW0=","filePath":"internal/queries/setting.go","content":"package queries\nfunc (q *SettingQueries) UpdateSettingByGroup(ctx context.Context, settings any) error {\n\tfieldMap := q.GroupFieldMap(settings)\n\n\ttx, err := q.DB.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer tx.Rollback()\n\n\tquery := `UPDATE setting SET value = ? WHERE key = ?`\n\tstmt, err := tx.PrepareContext(ctx, query)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tfor key, value := range fieldMap {\n\t\tif _, err = stmt.ExecContext(ctx, value, key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn tx.Commit()\n}\n// UpdatePassword updates the current user's password in the database.\nfunc (q *SettingQueries) UpdatePassword(ctx context.Context, password *models.Password) error {\n\tvar passwordHash string\n\tquery := `SELECT value FROM setting WHERE key = 'password'`\n\tif err := q.DB.QueryRowContext(ctx, query).Scan(&passwordHash); err != nil {\n\t\treturn errors.ErrUserNotFound\n\t}\n\tcompareUserPassword := security.ComparePasswords(passwordHash, password.Old)\n\tif !compareUserPassword {\n\t\treturn errors.ErrWrongPassword\n\t}\n\n\tquery = `UPDATE setting SET value = ? WHERE key = 'password'`\n\t_, err := q.DB.ExecContext(ctx, query, security.GeneratePassword(password.New))\n\treturn err\n}\n// GetSettingByKey retrieves a setting by its key from the database.\n// It accepts a context for cancellation and a string representing the key of the setting.\n// Returns a pointer to a SettingName model if found, or an error if not found or any other issue occurs."}