{"chunk":9,"numChunks":16,"fileHash":"OT1E1nCU/oF1uHBrV3/HQPWCZYVu1GcjnTiimB778ug=","filePath":"internal/queries/products.go","content":"package queries\nfunc (q *ProductQueries) IsProduct(ctx context.Context, slug string) bool {\n\tvar exists bool\n\tquery := `\n\t\t\tSELECT EXISTS (\n\t\t\t\tSELECT 1 FROM product \n\t\t\t\tWHERE product.slug = ? AND product.active = 1 AND (\n\t\t\t\t\tEXISTS (\n\t\t\t\t\t\tSELECT 1 FROM digital_data \n\t\t\t\t\t\tWHERE digital_data.product_id = product.id \n\t\t\t\t\t\tAND digital_data.content IS NOT NULL \n\t\t\t\t\t\tAND digital_data.cart_id IS NULL\n\t\t\t\t\t) OR EXISTS (\n\t\t\t\t\t\tSELECT 1 FROM digital_file \n\t\t\t\t\t\tWHERE digital_file.product_id = product.id \n\t\t\t\t\t\tAND digital_file.orig_name IS NOT NULL\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t`\n\terr := q.DB.QueryRowContext(ctx, query, slug).Scan(&exists)\n\treturn err == nil && exists\n}\n// UpdateActive toggles the 'active' status of a product and updates its 'updated' timestamp.\n// It takes a context and an ID as arguments, and returns an error if the operation fails.\nfunc (q *ProductQueries) UpdateActive(ctx context.Context, id string) error {\n\tquery := `UPDATE product SET active = NOT active, updated = datetime('now') WHERE id = ?`\n\t_, err := q.DB.ExecContext(ctx, query, id)\n\treturn err\n}\ntype productImage struct {\n\tID   string\n\tName string\n\tExt  string\n}\nfunc (q *ProductQueries) ProductImages(ctx context.Context, id string) (*[]models.File, error) {\n\timages, err := q.fetchProductImages(ctx, id)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fetching product images: %w\", err)\n\t}\n\n\treturn q.mapToModelFiles(images), nil\n}"}